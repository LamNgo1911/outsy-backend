generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Status {
  ACTIVE
  BANNED
  INACTIVE
}

model User {
  id             String   @id @default(cuid())
  username       String   @unique
  email          String   @unique
  password       String
  firstName      String
  lastName       String
  gender         String
  birthdate      DateTime
  bio            String?
  profilePicture String?
  location       String
  interests      String[]
  status         Status // e.g., "active", "banned", "inactive"

  // Activity & Preferences
  onlineStatus Boolean  @default(false) // Whether the user is currently online
  preferences  Json // E.g., gender, age range, distance for matching
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  igUrl        String? // Instagram URL
  // Photo        Photo[]

  /**
   * Virtual columns (relations) do not exist as a physical column in the database table
   * but behaves like one for querying and data access purposes.
   * It allows you to access related data from another table
   * without explicitly storing it in the current table.
   */
  chats             UserChat[]
  feedbacksReceived Feedback[] @relation("FeedbackRecipient") // Back relation for `user` in Feedback
  feedbacksGiven    Feedback[] @relation("FeedbackGiver") // Back relation for `giver` in Feedback
  // matches       Match[] // Matches with other users
  // likes         Like[] // Likes sent to other users
  // receivedLikes Like[] // Likes received from other users
}

model Chat {
  id       String  @id @default(cuid())
  isActive Boolean @default(true)
  // createdAt DateTime   @default(now())

  users    UserChat[]
  messages Message[]
}

model UserChat {
  userId String
  chatId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@id([userId, chatId]) // Composite primary key. In SQL, this is PRIMARY KEY (userId, chatId), 
}

model Message {
  id       String   @id @default(cuid())
  chatId   String
  senderId String
  content  String
  sentAt   DateTime @default(now())
  isRead   Boolean  @default(false)

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
}

model Feedback {
  id        String   @id @default(cuid())
  userId    String
  giverId   String
  text      String
  createdAt DateTime @default(now())

  user  User @relation("FeedbackRecipient", fields: [userId], references: [id]) // Forward relation
  giver User @relation("FeedbackGiver", fields: [giverId], references: [id]) // Forward relation
}

// model Matches {
//   id         Int       @id @default(autoincrement())
//   user1Id    Int
//   user2Id    Int
//   matchedAt  DateTime  @default(now())
//   isActive   Boolean   @default(true) // Whether the match is still active
//   user1      User      @relation(fields: [user1Id], references: [id])
//   user2      User      @relation(fields: [user2Id], references: [id])
// }

// model Likes {
//   id         Int      @id @default(autoincrement())
//   senderId   Int
//   receiverId Int
//   sentAt     DateTime @default(now())
//   sender     User     @relation(fields: [senderId], references: [id])
//   receiver   User     @relation(fields: [receiverId], references: [id])
// }

// model Photos {
//   id         Int      @id @default(autoincrement())
//   userId     Int
//   url        String
//   uploadedAt DateTime @default(now())
//   user       User     @relation(fields: [userId], references: [id])
// }

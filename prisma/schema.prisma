generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Status {
  ACTIVE
  BANNED
  INACTIVE
}

// User model to store user information
model User {
  id             String   @id @default(cuid())
  username       String   @unique
  email          String   @unique
  password       String
  firstName      String
  lastName       String
  gender         String
  birthdate      DateTime
  bio            String?
  profilePicture String?
  location       String
  interests      String[]
  status         Status // e.g., "active", "banned", "inactive"

  // Activity & Preferences
  onlineStatus Boolean  @default(false) // Whether the user is currently online
  preferences  Json // E.g., gender, age range, distance for matching
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  igUrl        String? // Instagram URL

  /**
   * Virtual columns (relations) do not exist as a physical column in the database table
   * but behaves like one for querying and data access purposes.
   * It allows you to access related data from another table
   * without explicitly storing it in the current table.
   */
  chats             UserChat[]
  feedbacksReceived Feedback[]  @relation("FeedbackRecipient")
  feedbacksGiven    Feedback[]  @relation("FeedbackGiver")
  hostedEvents      Event[]     @relation("EventHost")
  eventLikes        EventLike[]
  hostMatches       Match[]     @relation("MatchHost")
  guestMatches      Match[]     @relation("MatchGuest")
}

// Chat model to store the chat rooms between users
model Chat {
  id        String   @id @default(cuid())
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  users    UserChat[]
  messages Message[]
  matches  Match[]    @relation("MatchChat")
}

model UserChat {
  userId String
  chatId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@id([userId, chatId])
}

model Message {
  id       String   @id @default(cuid())
  chatId   String
  senderId String
  content  String
  sentAt   DateTime @default(now())
  isRead   Boolean  @default(false)

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
}

// Feedback model to store the feedback given by users
model Feedback {
  id        String   @id @default(cuid())
  userId    String
  giverId   String
  text      String
  createdAt DateTime @default(now())

  user  User @relation("FeedbackRecipient", fields: [userId], references: [id])
  giver User @relation("FeedbackGiver", fields: [giverId], references: [id])
}

// Event model to store the events created by users
model Event {
  id          String      @id @default(cuid())
  hostId      String
  name        String
  description String?
  type        EventType   @default(FOOD)
  date        DateTime
  venueId     String
  status      EventStatus @default(OPEN)
  capacity    Int         @default(2)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  //relation
  host      User        @relation("EventHost", fields: [hostId], references: [id])
  venue     Venue       @relation("EventVenue", fields: [venueId], references: [id])
  EventLike EventLike[]
  Match     Match[]
}

enum EventType {
  FOOD
  DRINKS
  ACTIVITY
  OTHER
}

enum EventStatus {
  OPEN // Event is open for registration
  CLOSED // Event registration is closed
  CANCELLED // Event is cancelled
}

// EventLike model to store the likes from users to events
model EventLike {
  id        String     @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime   @default(now())
  status    LikeStatus @default(PENDING)
  message   String? // Optional message from user showing interest

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId]) // A user can only like an event once
}

enum LikeStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Match model to store the matches between users and events
model Match {
  id        String      @id @default(cuid())
  eventId   String
  hostId    String
  guestId   String
  chatId    String?
  status    MatchStatus @default(CONFIRMED)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  host  User  @relation("MatchHost", fields: [hostId], references: [id])
  guest User  @relation("MatchGuest", fields: [guestId], references: [id])
  chat  Chat? @relation("MatchChat", fields: [chatId], references: [id])

  @@unique([eventId, guestId]) // Ensures a user can only match once with an event
}

enum MatchStatus {
  CONFIRMED // when host accepts guest's request
  COMPLETED // when the event is over
  CANCELLED // when either party cancels the match
}

//ANCHOR - there are two cases where it comes CANCELLED status:
// 1. Host cancels event: Event status changes to CANCELLED - send notification to the guest
// 2. Guest cancels match -> Send notification to the host to decide if they want to cancel the event or find a new guest
// NOTE: They can only cancel the match before 3 hours of the event start time

// Venue model to store the venue information from Google Places API
model Venue {
  id          String  @id @default(cuid())
  name        String
  address     String
  city        String
  state       String?
  country     String
  postalCode  String
  description String?
  imageUrl    String?

  //relation
  events Event[] @relation("EventVenue")
}
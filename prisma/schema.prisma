generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Status {
  ACTIVE
  BANNED
  INACTIVE
}

enum Role {
  USER
  ADMIN
}

// User model to store user information
model User {
  id             String   @id @default(cuid())
  username       String   @unique
  email          String   @unique
  password       String
  firstName      String
  lastName       String
  gender         String
  birthdate      DateTime // For age-based matching or filtering
  bio            String? // Short description for personality
  profilePicture String? // Visual appeal for hangout pairing
  location       String // Broad location for proximity matching
  interests      String[] // E.g., ["food", "drinks", "hiking"]
  status         Status   @default(ACTIVE) // ACTIVE, BANNED, INACTIVE
  role           Role     @default(USER) // USER, ADMIN

  // Activity & Preferences
  onlineStatus Boolean  @default(false) // Whether the user is currently online
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  igUrl        String? // Instagram URL

  // Relations
  preferences       Preference?
  chats             UserChat[]
  feedbacksReceived Feedback[]     @relation("FeedbackRecipient")
  feedbacksGiven    Feedback[]     @relation("FeedbackGiver")
  hostedEvents      Event[]        @relation("EventHost")
  eventLikes        EventLike[]
  hostMatches       Match[]        @relation("MatchHost")
  guestMatches      Match[]        @relation("MatchGuest")
  refreshTokens     RefreshToken[] // New relation
}

model Preference {
  id           String   @id @default(cuid())
  userId       String   @unique
  activities   String[]
  distance     Int      @default(10)
  ageRangeMin  Int      @default(18)
  ageRangeMax  Int      @default(35)
  matchNotif   Boolean  @default(true)
  messageNotif Boolean  @default(true)
  eventNotif   Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// RefreshToken model to store the refresh tokens for users
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique // Hashed refresh token
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime // Expiration date

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Chat model to store the chat rooms between users
model Chat {
  id        String   @id @default(cuid())
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  userChats UserChat[]
  messages  Message[]
  matches   Match[]    @relation("MatchChat")
}

model UserChat {
  userId String
  chatId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@id([userId, chatId])
}

model Message {
  id       String   @id @default(cuid())
  chatId   String
  senderId String
  content  String
  sentAt   DateTime @default(now())
  isRead   Boolean  @default(false)

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
}

// Feedback model to store the feedback given by users
model Feedback {
  id        String   @id @default(cuid())
  userId    String
  giverId   String
  text      String
  createdAt DateTime @default(now())

  user  User @relation("FeedbackRecipient", fields: [userId], references: [id])
  giver User @relation("FeedbackGiver", fields: [giverId], references: [id])
}

// Event model to store the events created by users
model Event {
  id          String      @id @default(cuid())
  hostId      String
  name        String
  description String?
  type        EventType   @default(FOOD)
  date        DateTime
  venueId     String
  status      EventStatus @default(OPEN)
  capacity    Int         @default(2)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  //relation
  host      User        @relation("EventHost", fields: [hostId], references: [id])
  venue     Venue       @relation("EventVenue", fields: [venueId], references: [id])
  EventLike EventLike[]
  Match     Match[]
}

enum EventType {
  FOOD
  DRINKS
  ACTIVITY
  OTHER
}

enum EventStatus {
  OPEN // Event is open for registration
  CLOSED // Event registration is closed
  CANCELLED // Event is cancelled
}

// EventLike model to store the likes from users to events
model EventLike {
  id        String     @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime   @default(now())
  status    LikeStatus @default(PENDING)
  message   String? // Optional message from user showing interest
  updatedAt DateTime   @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId]) // A user can only like an event once
}

enum LikeStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Match model to store the matches between users and events
model Match {
  id        String      @id @default(cuid())
  eventId   String
  hostId    String
  guestId   String
  chatId    String?
  status    MatchStatus @default(CONFIRMED)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  host  User  @relation("MatchHost", fields: [hostId], references: [id])
  guest User  @relation("MatchGuest", fields: [guestId], references: [id])
  chat  Chat? @relation("MatchChat", fields: [chatId], references: [id])

  @@unique([eventId, guestId]) // Ensures a user can only match once with an event
}

enum MatchStatus {
  CONFIRMED // when host accepts guest's request
  COMPLETED // when the event is over
  CANCELLED // when either party cancels the match
}

//ANCHOR - there are two cases where it comes CANCELLED status:
// 1. Host cancels event: Event status changes to CANCELLED - send notification to the guest
// 2. Guest cancels match -> Send notification to the host to decide if they want to cancel the event or find a new guest
// NOTE: They can only cancel the match before 3 hours of the event start time

// Venue model to store the venue information from Google Places API
model Venue {
  id          String  @id @default(cuid())
  name        String
  address     String
  city        String
  state       String?
  country     String
  postalCode  String
  description String?
  imageUrl    String?

  //relation
  events Event[] @relation("EventVenue")
}
